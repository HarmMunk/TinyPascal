; PASCAL RUN-TIME ROUTINES
; BY H. YUEN
; VERSION 3.0 MAY/JULY 2012 BY H. MUNK

; CP/M EQUATES

BDOS	EQU		0005H

; CP/M DOS FUNCTIONS
B$SYSRESET	EQU	0	; SYSTEM RESET
B$CONIN		EQU	1	; CONSOLE INPUT
B$CONOUT	EQU	2	; CONSOLE OUTPUT

B$TOPRAM	EQU	7	; MSB OF ADDRESS OF START OF BDOS

CR		EQU	13
LF		EQU	10

; INVARIANTS
; VALUES ON THE STACK ARE STORED BIG ENDIAN (HIGH BYTE AT LOW ADDRESS)
; DE CONTAINS TOP-OF-STACK AND POINTS TO THE LSBYTE OF THE TOP VALUE
; BB CONTAINS BASE ADDRESS AND POINTS TO THE LSBYTE OF THE LOWEST WORD
; OF THE STACK FRAME:
;	+-----------------------+
;	| LSBYTE VARIABLE 2     |	<== DE (STACK POINTER)
;	+-----------------------+
;	| MSBYTE VARIABLE 2     |
;	+-----------------------+
;	| LSBYTE VARIABLE 1     |
;	+-----------------------+
;	| MSBYTE VARIABLE 1     |
;	+-----------------------+
;	| LSBYTE RETURN ADDRESS |
;	+-----------------------+
;	| MSBYTE RETURN ADDRESS |
;	+-----------------------+
;	| LSBYTE DYNAMIC LINK   |
;	+-----------------------+
;	| MSBYTE DYNAMIC LINK   |
;	+-----------------------+
;	| LSBYTE STATIC LINK    |	<== BB (BASE POINTER)
;	+-----------------------+
;	| MSBYTE STATIC LINK    |
;	+-----------------------+
;	| LSBYTE PARAMETER N    |
;	+-----------------------+
;	| MSBYTE PARAMETERN     |
;	+-----------------------+
;	| LSBYTE PARAMETER      |
;	+-----------------------+
;	| MSBYTE PARAMETER      |
;	+-----------------------+
;

; THE FOLLOWING SECTION CONTAINS A TABLE WITH THE ADDRESSES
; OF ALL RELEVANT P-CODE ROUTINES
; THIS WILL SHOW UP AS A SEPARATE SECTION IN THE HEX FILE
; THE P-CODE-TO-8080 TRANSLATOR USES THE ADDRESSES FROM THIS TABLE.
; THE TABLE WILL NOT SHOW UP IN THE TRANSLATED FILE
; THIS TABLE MAKES THE TRANSLATOR RUN-TIME ROUTINE POSITION INDEPENDENT

	ORG	100H
	DB	'PR01'
	DW	(TABLE$END-TABLE$START)/2
TABLE$START:
	DW	INIT
	DW	LIT
	DW	INT

	DW	LODA
	DW	LOD
	DW	LOD1
	DW	LODX
	DW	LODX1

	DW	STOA
	DW	STO
	DW	STO1
	DW	STOX
	DW	STOX1

	DW	CALA
	DW	CAL
	DW	CAL1

	DW	OPR00$00
	DW	OPR00$01
	DW	OPR00$02
	DW	OPR00$03

	DW	OPR00$04
	DW	OPR00$05
	DW	OPR00$06
	DW	OPR00$07

	DW	OPR00$08
	DW	OPR00$09
	DW	OPR00$0A
	DW	OPR00$0B

	DW	OPR00$0C
	DW	OPR00$0D
	DW	OPR00$0E
	DW	OPR00$0F

	DW	OPR00$10
	DW	OPR00$11
	DW	OPR00$12
	DW	OPR00$13
	
	DW	OPR00$14
	DW	OPR00$15
	DW	OPR00$16
	DW	OPR00$17

	DW	SP0
	DW	SP1
	DW	SP2
	DW	SP3
	
	DW	SP4
	DW	SP5
;	DW	SP6
;	DW	SP7

	DW	SP8
TABLE$END:
	DW	PROGB

	ORG	100H
; AS THIS IS THE FIRST INSTRUCTION EXECUTED AFTER LOADING BY CP/M, IT
; MUST CONTAIN A JUMP TO THE FIRST INSTRUCTION OF THE PROGRAM

	JMP	INIT

; STORAGE
BB:	DW	0		; BASE REGISTER
STACK2:	DW	0		; COMPLEMENT OF STACK TOPMOST ADDRESS

; INITIALISATION
; INIT BASE POINTER (BB), TOP OF STACK (STACK2), STACK POINTER (DE), AND
; SAVE EXIT ADDRESS AS DYNAMIC LINK IN STACK FRAME OF MAIN PROGRAM

; 8080 STACK USAGE: 0 BYTES
INIT:				; INIT BASE POINTER
	LXI	H,0		; ADDRESS OF FIRST WORD BEYOND PROGRAM
				; TO BE FILLED IN BY P-CODE TRANSLATOR
	INX	H		; POINT TO LOW ORDER BYTE
	SHLD	BB		; SAVE AS BASE POINTER
	DCX	H		; POINT BELOW STACK
	DCX	H
	XCHG			; STACK POINTER TO DE
	LDA	B$TOPRAM	; GET TOP OF TPA
	DCR	A		; BACK OFF ONE PAGE
	CMA
	MOV	H,A		; ...TO H
	MVI	L,001H		; FORM COMPLEMENT OF ADDRESS
	SHLD	STACK2		; SAVE TOP OF STACK
	LXI	H,5
	DAD	D		; HL POINT TO DYNAMIC LINK OF MAIN
				;                                PROGRAM
	LXI	B,EXIT		; GET EXIT ADDRESS
	MOV	M,B		; SAVE EXIT ADDRESS AS DYNAMIC LINK
	INX	H
	MOV	M,C
	LXI	H,PROGB-1	; INIT 8080 STACK
	SPHL
	JMP	PROGB		; DONE, START PROGRAM

; AS A FURTHER REDUSCTION OF MEMORY USAGE, THE INIT ROUTINE COULD BE
; MOVED INTO THE STACK AREA, TO BE OVERWRITTEN BY THE STACK ONCE IT HAS
; DONE ITS JOB

; OPR 0,0	: PROCEDURE OR FUNCTION RETURN
; 8080 STACK USAGE: 0 BYTES
OPR00$00:
	LHLD	BB		; GET CURRENT BASE ADDRESS
	INX	H		; POINT TO DYNAMIC LINK
	MOV	D,M		; LOAD DYNAMIC LINK IN DE
	INX	H
	MOV	E,M
	XCHG
	SHLD	BB		; SAVE DYNAMIC LINK AS NEW BASE ADDRESS
	XCHG
	INX	H		; LOAD RETURN ADDRESS IN DE
	MOV	D,M
	INX	H
	MOV	E,M
	LXI	B,-6
	DAD	B		; DECREMENT STACK POINTER BY THREE WORDS
	XCHG			; STACK POINTER TO DE, RETURN ADDRESS TO HL
	PCHL

; OPR 0,1	: [SP] := -[SP] : NEGATE TOP OF STACK ELEMENT
; 8080 STACK USAGE: 0 BYTES
OPR00$01:
	XCHG			; STACK POINTER TO HL
	XRA	A		; CLEAR A
	SUB	M		; A = -LBYTE
	MOV	M,A		; PUT BACK
	MOV	C,A		; C = -LBYTE
	DCX	H		; POINT TO HIGH ORDER BYTE
	SBB	M		; A = -LBYTE - HBYTE
	SUB	C		; A = -LBYTE - HBYTE - (-LBYTE) = -HBYTE
	MOV	M,A		; PUT BACK
	INX	H		; REPAIR STACK POINTER
	XCHG			; STACK POINTER TO DE
	RET

; OPR 0,2	: [SP-1] := [SP-1] + [SP]
; 8080 STACK USAGE: 2+#'PPOP' BYTES
OPR00$02:
	CALL	PPOP		; POP TOP TWO ELEMENTS
	JMP	ADD16		; DO THE 16 ADDITION, PUSH RESULT ON STACK,
				; RETURN THERE

; OPR 0,3	: [SP-1] := [SP-1] - [SP]
; 8080 STACK USAGE:  2+#'PPOP' BYTES
OPR00$03:
	CALL	PPOP		; POP TOP TWO ELEMENTS
	MOV	A,B		; GET MSB IN A
	SUI	80H		; SUBTRACT -128(*256)
	ORA	C		; IS BC == -32768
	JNZ	SUB1		; NO, DO THE SUBTRACT
	MOV	A,C		; -(-32768) GIVES OVERFLOW
	JMP	SU2

; OPR 0,4	: [SP-1] := [SP-1] * [SP]
; 8080 STACK USAGE:  MAX(2+#'PPOP', PPUSH) BYTES
OPR00$04:
	CALL PPOP		; POP TOP TWO ELEMENTS
	PUSH	D		; SAVE STACK POINTER
	MOV	A,H		; GET HIGH BYTE OF [SP-1]
	MOV	E,L		; SAVE LOW BYTE [SP-1]
	LXI	H,0		; CLEAR RESULT
	ORA	A		; SEE IF MSB [SP-1] IS ZERO
	CNZ	MUL8
	MOV	A,E
	CALL	MUL8
	POP	D		; RESTORE STACK POINTER
	JMP	PPUSH		; PUSH RESULT, RETURN THERE

; OPR 0,5	: [SP-1] := [SP-1] / [SP]
; 8080 STACK USAGE: MAX(2+MAX(2+#'PPOP', 2+#'DIV16'), 'PPUSH') BYTES
OPR00$05:
	CALL PPOP		; POP TOP TWO ELEMENTS
	PUSH	D		; SAVE STACK POINTER
	CALL	DIV16		; DO THE DIVIDE
	POP	D		; RESTORE STACK POINTER
	JMP	PPUSH		; GO PUSH RESULT, RETURN THERE

; OPR 0,6	: [SP-1] := ODD([SP])
; 8080 STACK USAGE: 0 BYTES
OPR00$06:
	LDAX	D		; GET LSB
	ANI	1		; TEST BIT 0
	STAX	D		; SAVE LSB OF RESULT
	DCX	D		; POINT TO MSB
	XRA	A		; CLEAR A
	STAX	D		; SAVE MSB OF RESULT
	INX	D		; ADJUST STACK POINTER
	RET

; OPR 0,7	: [SP-1] := [SP-1] MOD [SP]
; 8080 STACK USAGE: MAX(2+MAX(2+#'PPOP', 2+2+#'DIV16'), #'PPUSH') BYTES
OPR00$07:
	CALL PPOP		; POP TOP TWO ELEMENTS
	PUSH	D		; SAVE STACK POINTER
	CALL	DIV16		; DO THE DIVIDE
	XCHG			; FLIP REMAINDER TO HL
	POP	D		; RESTORE STACK POINTER
	JMP	PPUSH		; GO PUSH RESULT, RETURN THERE

; OPR 0,8	: [SP-1] := ([SP-1] = [SP])
; 8080 STACK USAGE: 0 BYTES
OPR00$08:
	MVI	A,1		; LOAD FLAGS
	JMP	EQUAL		; GO TEST

; OPR 0,9	: [SP-1] := ([SP-1] <> [SP])
; 8080 STACK USAGE: 0 BYTES
OPR00$09:
	XRA	A		; LOAD FLAGS
	JMP	EQUAL		; GO TEST

; OPR 0,10	: [SP-1] := ([SP-1] < [SP])
; 8080 STACK USAGE: 0 BYTES
OPR00$0A:
	LXI	B,0100H		; LOAD FLAGS
		JMP LESS	; GO TEST

; OPR 0,11	: [SP-1] := ([SP-1] >= [SP])
; 8080 STACK USAGE: 0 BYTES
OPR00$0B:
	LXI	B,0000H		; LOAD FLAGS
		JMP LESS	; GO TEST

; OPR 0,12	: [SP-1] := ([SP-1] > [SP])
; 8080 STACK USAGE: 0 BYTES
OPR00$0C:
	LXI	B,0001H		; LOAD FLAGS
		JMP LESS	; GO TEST

; OPR 0,13	: [SP-1] := ([SP-1] < [SP])
; 8080 STACK USAGE: 0 BYTES
OPR00$0D:
	LXI	B,0101H		; LOAD FLAGS
		JMP LESS	; GO TEST

; OPR 0,14	: [SP-1] := [SP-1] OR [SP]
; 8080 STACK USAGE: 2+#'PPOP' BYTES
OPR00$0E:
	CALL PPOP		; POP TOP TWO ELEMENTS
	MOV	A,H		; 'OR' HIGH ORDER BYTES
	ORA	B
	INX	D
	STAX	D		; PUSH RESULT
	MOV	A,L		; 'OR' LOW ORDER BYTES
	ORA	C
	INX	D
	STAX	D		; PUSH RESULT
	RET

; OPR 0,15	: [SP-1] := [SP-1] AND [SP]
; 8080 STACK USAGE: 2+#'PPOP' BYTES
OPR00$0F:
	CALL PPOP		; POP TOP TWO ELEMENTS
	MOV	A,H		; 'OR' HIGH ORDER BYTES
	ANA	B
	INX	D
	STAX	D		; PUSH RESULT
	MOV	A,L		; 'OR' LOW ORDER BYTES
	ANA	C
	INX	D
	STAX	D		; PUSH RESULT
	RET

; OPR 0,16	: [SP] := COMPLEMENT [SP]
; 8080 STACK USAGE: 0 BYTES
OPR00$10:
	LDAX	D		; GET LOW ORDER BYTE
	CMA			; COMPLEMENT
	STAX	D		; SAVE
	DCX	D
	LDAX	D		; GET HIGH ORDER BYTE
	CMA			; COMPLEMENT
	STAX	D		; SAVE
	INX	D		; REPAIR STACK POINTER
	RET

; OPR 0,17	: [SP-1] := [SP-1] SHL [SP]
; 8080 STACK USAGE: MAX(2+MAX(#'PPOP'), #'PPUSH',#'OPR00$12$1',#'OPR00$11$1') BYTES
OPR00$11:
	CALL	PPOP		; POP TOP TWO ELEMENTS
	XRA	A		; CLEAR A
	ADD	C		; GET C, SET FLAGS
	JZ	PPUSH		; DO NOTHING IF ZERO
	JM	OPR00$12$1		; SHIFT RIGH IF <0
OPR00$11$1:
	DAD	H		; SHIFT LEFT ONE PLACE
	DCR	A
	JNZ	OPR00$11$1	; LOOP FOR ALL
	JMP	PPUSH		; GO PUSH RESULT, RETURN THERE

; OPR 0,18	: [SP-1] := [SP-1] SHR [SP]
; 8080 STACK USAGE: MAX(2+MAX(#'PPOP'), #'PPUSH',#'OPR00$12$1',#'OPR00$11$1') BYTES
OPR00$12:
	CALL	PPOP		; POP TOP TWO ELEMENTS
	XRA	A		; CLEAR A
	SUB	C		; NEGATE C, SET FLAGS
	JZ	PPUSH		; DO NOTHING IF ZERO
	JP	OPR00$11$1	; SHIFT RIGHT IF >0
	MOV	C,A		; -COUNT IN C
OPR00$12$1:
	XRA	A
	ORA	H		; GET H, RESET CARRY
	RAR			; SHIFT RIGHT
	MOV	H,A		; SAVE RESULT
	MOV	A,L
	RAR			; MOVE CARRY IN
	MOV	L,A
	INR	C		; COUNT UP TO 0
	JNZ	OPR00$12$1	; LOOP FOR ALL
	JMP	PPUSH		; GO PUSH RESULT, RETURN THERE

; OPR 0,19	: [SP] := [SP] + 1
; 8080 STACK USAGE: 0 BYTES
OPR00$13:
	LDAX	D		; GET LOW ORDER BYTE
	ADI	1		; INCREMENT
	STAX	D		; SAVE INCREMENTED LOW ORDER BYTE
	RNC			; DONE IF NO CARRY
	MOV	H,D		; COPY STACK POINTER IN HL
	MOV	L,E
	DCX	H		; POINT TO HIGH ORDER BYTE
	INR	M		; INCREMENT HIGH ORDER BYTE
	RET

; OPR 0,20	: [SP] := [SP] - 1
; 8080 STACK USAGE: 0 BYTES
OPR00$14:
	LDAX	D		; GET LOW ORDER BYTE
	SUI	1		; DECCREMENT
	STAX	D		; SAVE INCREMENTED LOW ORDER BYTE
	RNC			; DONE IF NO CARRY
	MOV	H,D		; COPY STACK POINTER IN HL
	MOV	L,E
	DCX	H		; POINT TO HIGH ORDER BYTE
	DCR	M		; INCREMENT HIGH ORDER BYTE
	RET

; OPR 0,21	: [SP+1] := [SP]
; 8080 STACK USAGE: 0 BYTES
OPR00$15:
	MOV	H,D		; COPY STACK POINTER IN HL
	MOV	L,E
	INX	D		; POINT TO NEXT STACK ELEMENT
	DCX	H		; POINT TO LSB OF CURRENT STACK ELEMENT
	MOV	A,M		; GET BYTE
	STAX	D		; COPY
	INX	H
	INX	D		; BOTH POINTERS TO NEXT BYTE
	MOV	A,M		; GET BYTE
	STAX	D		; COPY
	RET

; OPR 0,22	: [SP-1] := BDOS([SP-1], [SP])
; 8080 STACK USAGE: 4 BYTES
OPR00$16:
	CALL	PPOP		; POP [SP] IN BC, [SP-1] IN HL
	PUSH	D		; SAVE MY SP
	MOV	E,C		; MOVE ARGUMENT TO BDOS...
	MOV	D,B		; ...TO DE
	MOV	C,L		; MOVE BDOS FUNCTION NUMBER TO C
	CALL	BDOS		; DO THE BDOS FUNCTION
	POP	D		; POP MY STACK POINTER
	JMP	PPUSH		; PUSH RETURNED VALUE IN HL ON MY STACK, RETURN THERE

; OPR 0, 23	: [SP] := -(STACK2+[SP]); STACK := STACK2+[SP]
; 8080 STACK USAGE: 4 BYTES
OPR00$17:
	CALL 	POP1		; POP TOP ELEMENT TO HL: DELTA TO DECREASE STACK SPACE WITH
	PUSH	D		; SAVE SP
	XCHG			; DELTA TO DE
	LHLD	STACK2		; GET COMPLEMENT OF CURRENT STACK TOP IN HL
	DAD	D		; ADD DELTA: HL = -(STACKTOP-DELTA)
	POP	D		; GET SP BACK
	PUSH	D		; DON'T SAVE JUST YET
	PUSH	H		; SAVE NEW COMPLEMENT OF STACK SPACE END
	DAD	D		; CHECK IF SUFFICIENT STACK SPACE LEFT
	POP	H		; GET NEW COMPLEMENT OF STACK SPACE END BACK
	POP	D		; RESTORE STACK
	JC	STKOV		; JUMP ON OUT OF STACK SPACE
	SHLD	STACK2		; SAVE NEW COMPLEMENT OF STACK SPACE END
	CALL	NEGH		; FORM ADDRESS OF STACK TOP
	JMP	PPUSH		; STORE ON STACK
	
; SP0		: INPUT A CHARACTER
; 8080 STACK USAGE: 2+#'INP' BYTES
SP0:	INX	D
	XRA	A
	STAX	D		; CLEAR HIGH ORDER BYTE
	INX	D		; POINT TO LOW ORDER BYTE
	CALL	INP		; GET A CHARACTER
	STAX	D		; PUSH ON STACK
	RET

; SP 1		: OUTPUT A CHARACTER
; 8080 STACK USAGE: #'OUTP' BYTES
SP1:	LDAX	D		; POP CHARACTER
	DCX	D		; DECREMENT STACK POINTER
	DCX	D
	JMP	OUTP		; GO OUTPUT, RETURN THERE

; SP 2		: INPUT A DECIMAL NUMBER
; 8080 STACK USAGE: MAX(2+2+MAX(#'OUTP', #'INP'), #'PPUSH') BYTES
SP2:	PUSH	D		; SAVE STACK POINTER
SP2$1:	MVI	A,'?'		; PRINT A '?' PROMPT
	MOV	D,A		; SET INIT FLAG
	CALL	OUTP
	XRA	A		; CLEAR SIGN
	STA	SIGN
	MOV	H,A		; CLEAR RESULT
	MOV	L,A
SP2$2:	CALL INP		; GET A CHARACTER
	CPI	' '		; IGNORE SPACES
	JZ	SP2$2
	CPI	'+'		; PLUS?
	JZ	SP2$3		; IGNORE PLUS
	CPI	'-'		; MINUS?
	JNZ	SP2$4		; JUMP IF NOT MINUS
	STA	SIGN		; SAVE SIGN
SP2$3:	CALL	INP		; STEP OVER '+' OR '-'
SP2$4:	SUI	'0'		; CONVERT ASCII TO BINARY
	JM	SP2$6		; JUMP IF NOT A DIGIT
	CPI	10		; MUST BE IN RANGE 0 .. 9
	JP	SP2$6		; JUMP IF NOT A DIGIT
	MOV	E,A		; MOVE TO DE
	XRA	A		; CLEAR INIT FLAG
	MOV	D,A
	DAD	H		; RESULT*2
	ADC	A		; CATCH OVERFLOW IN A
	MOV	B,H		; COPY IN BC
	MOV	C,L
	DAD	H		; RESULT*4
	ADC	A		; CATCH OVERFLOW IN A
	DAD	H		; RESULT*8
	ADC	A		; CATCH OVERFLOW IN A
	DAD	B
	ADC	A		; CATCH OVERFLOW IN A
	DAD	D		; ADD DIGIT
	ADC	A		; CATCH OVERFLOW IN A
	JNZ	SP2$5		; JUMP IF OVERFLOW
	ORA	H		; A IS ZERO, TEST MSB
	JP	SP2$3		; GO FOR NEXT DIGIT
SP2$5:	LXI	H,MER2		; GET ERROR MESSAGE
	JMP	SP2$8		; GO PRINT, TRY AGAIN

SP2$6:	XRA	A		; TEST INIT FLAG
	ADD	D 	
	JNZ	SP2$7		; ERROR IF NO DIGITS
	LDA	SIGN		; TEST SIGN
	ORA	A
	CNZ	NEGH		; NEGATE HL IF SET
	POP	D		; RESTORE STACK POINTER
	INX	D		; POINT TO HIGH ORDER BYTE
	JMP	PPUSH		; GO PUSH NUMBER, RETURN THERE

SP2$7:	LXI	H,MER1		; LOAD ERROR MESSAGE
SP2$8:	CALL	PRINT		; PRINT ERROR MESSAGE
	JMP	SP2$1		; TRY AGAIN

; SP3		: OUTPUT [SP] DECIMAL
; 8080 STACK USAGE: MAX(2+#'PPOP',2+2+#'NEGH',4+2+MAX(#'DIV16',#'OUTP'))
SP3:	CALL	POP1		; POP TOP OF STCAK IN HL
	PUSH	D		; SAVE STACK POINTER
	MVI	C,' '		; DEFAULT SIGN CHARACTER
	XRA	A		; TEST SIGN
	ORA	H
	JP	SP3$1		; SKIP IF POSITIVE
	MVI	C,'-'		; SIGN CHARACTER
	CALL	NEGH		; NEGATE HL
SP3$1:	MVI	B,0		; CLEAR CHARACTER COUNT
SP3$2:	PUSH	B		; SAVE NUMBER OF CHARACTERS AND SIGN
	LXI	B,10		; DIVIDE BY 10
	CALL	DIV16
	POP	B		; RESTORE NUMBER OF CHARACTERS AND SIGN
	MVI	A,'0'		; CONVERT TO ASCII
	ADD	E
	PUSH	PSW		; SAVE CHARACTER ON STACK
	INR	B		; UPDATE NUMBER OF CHARACTERS
	MOV	A,H		; SEE IF 0 REMAINS
	ORA	L
	JNZ	SP3$2		; JUMP IF NOT 0
	MOV	A,C		; GET SIGN
	CALL	OUTP		; PRINT SIGN
SP3$4:	POP	PSW		; POP A DIGIT
	CALL	OUTP		; PRINT IT
	DCR	B
	JNZ	SP3$4		; LOOP FOR ALL DIGITS
	POP	D		; RESTORE STACK POINTER
	MVI	A,' '		; TRAILING BLANK
	JMP	OUTP		; PRINT SPACE, RETURN THERE

; SP4		: INPUT A HEX NUMBER
; 8080 STTACK USAGE: 2+#'INHEX' BYTES
SP4:	INX	D		; POINT TO HIGH ORDER BYTE
SP4$1:	CALL	INHEX		; GET 2 HEX DIGITS
	JC	SP4$1		; RETRY IF BAD DIGITS
	ADD	C		; MAKE INTO ONE BINARY
	STAX	D		; PUSH ON STACK
	CALL	INHEX
	JC	SP4$1		; RETRY IF BAD DIGITS
	ADD	C		; MAKE INTO ONE BINARY
	INX	D		; POINT TO LOW ORDER BYTE
	STAX	D		; PUSH ON STACK
	RET

; SP5		: OUTPUT [SP] HEX
; 8080 STTACK USAGE: 2+MACX(#'OUTP', #'HEX')
SP5:	MVI	A,' '		; PRINT A FORMATTING SPACE
	CALL	OUTP
	LDAX	D		; GET LOW ORDER BYTE
	MOV	L,A		; SAVE IN L
	DCX	D		; POINT TO HIGH ORDER BYTE
	LDAX	D		; GET HIGH ORDER BYTE
	DCX	D		; POINT TO NEW TOP
	CALL	HEX		; PRINT TWO HEX DIGITS OF HIGH ORDER BYTE
	MOV	A,L		; GET LOW ORDER BYTE
	CALL	HEX		; PRINT TWO HEX DIGITS OF LOW ORDER BYTE
	MVI	A,' '		; PRINT A FORMATTING SPACE
	JMP	OUTP		; PRINT, RETURN THERE

; SP8		: PRINT A STRING
; 8080 STACK USAGE: 2+#'OUTP'
SP8:	POP	H		; RETURN ADDRESS IS START OF STRING
SP8$1:	MOV	A,M		; GET A CHARACTER
	CALL	OUTP
	INX	H		; POINT TO NEXT CHARACTER
	DCR	B		; COUNT DOWN
	JNZ	SP8$1		; LOOP FOR ALL
	PCHL			; END OF STRING IS ACTUAL RETURN ADDRESS

; LIT		: LOAD LITERAL CONSTANT (FROM BC)
; 8080 STACK USAGE: 0 BYTES
LIT:	XCHG			; STACK POINTER TO HL
	INX	H		; POINT TO HIGH ORDER BYTE
	MOV	M,B		; SAVE MSB
	INX	H		; POINT TO LOW ORDER BYTE
	MOV	M,C		; SAVE LSB
	XCHG			; STACK POINTER BACK TO DE
	RET

; LOD 255,0		: LOAD FROM ABSOLUTE MEMORY ADDRESS
; 8080 STACK USAGE: 0 BYTES
LODA:	XCHG			; STACK POINTER TO HL
	MOV	E,M		; MOVE ADDRESS FROM TOP OF STACK TO DE
	DCX	H
	MOV	D,M
	MVI	M,0		; CLEAR HIGH ORDER BYTE
	LDAX	D		; FETCH BYTE FROM MEMORY
	INX	H
	MOV	M,A		; STORE IN STACK
	XCHG			; STACK POINTER BACK TO DE
	RET

; LOD L,D		: LOAD VARIABLE AT LEVEL L, DISPLACEMENT D
;			: L IN A, D IN BC
;			: LOD: LEVEL=0, LOD1: LEVEL IN A
; 8080 STACK USAGE: 2+ #'BASE' BYTES
LOD:	XRA	A		; CLEAR A
LOD1:	LHLD	BB		; GET BASE ADDRESS
	ORA	A		; EXAMINE LEVEL DIFFERENCE
	CNZ	BASE		; GET APPROPRIATE BASE ADDRESS IN HL
	INX	D		; ADJUST SP TO POINT TO MSB
	DAD	B		; ADD DISPLACEMENT
	DCX	H		; POINT TO MSB
	MOV	A,M		; MOVE VIA A TO STACK
	STAX	D
	INX	D		; POINT TO LSB
	INX	H
	MOV	A,M		; MOVE LSB VIA A TO STACK
	STAX	D
	RET

; LODX L,D		: LOAD VARIABLE INDEXED AT LEVEL L, DISPLACEMENT D
;			: L IN A, D IN BC, INDEX ON TOP OF STACK
;			: LODX: LEVEL=0, LODX1: LEVEL IN A
; 8080 STACK USAGE: 2+ #'BASE' BYTES
LODX:	XRA	A		; CLEAR A
LODX1:	LHLD	BB		; GET BASE ADDRESS
	ORA	A		; EXAMINE LEVEL DIFFERENCE
	CNZ	BASE		; GET APPROPRIATE BASE ADDRESS IN HL
	DAD	B		; ADD DISPLACEMENT
	XCHG			; SP TO HL, START OF ARRAY TO DE
	MOV	C,M		; POP INDEX
	DCX	H
	MOV	B,M
	XCHG			; SP TO DE, START OF ARRAY BACK IN HL
	DAD	B		; ADD INDEX...
	DAD	B		; ...TWICE
	DCX	H		; POINT TO MSB
	MOV	A,M		; MOVE VIA A TO STACK
	STAX	D
	INX	D		; POINT TO LSB
	INX	H
	MOV	A,M		; MOVE LSB VIA A TO STACK
	STAX	D
	RET

; STO 255,0		: STORE AT ABSOLUTE ADDRESS
; 8080 STACK USAGE: 2+#'POP1' BYTES
STOA:	LDAX	D		; GET VALUE TO BE STORED
	DCX	D
	DCX	D		; ADJUST STACK POINTER
	CALL	POP1		; POP ABSOLUTE ADDRESS FOR TOP OF STACK
	MOV	M,A		; STORE VALUE
	RET

; STO L,D		: STORE VARIABLE IN LEVEL L, DISPLACEMENT D
;			: L IN A, D IN BC
;			: STO: LEVEL = 0, STO1: LEVEL DIFFERENCE IN A
; 8080 STACK USAGE: 2+#'BASE'
STO:	XRA	A		; LEVEL = 0
STO1:	LHLD	BB		; GET BASE ADDRESS IN HL
	ORA	A		; EXAMINE LEVEL DIFFERENCE
	CNZ	BASE		; GET APPROPRIATE BASE
	DAD	B		; ADD DISPLACEMENT
	LDAX	D		; GET LOW ORDER BYTE
	MOV	M,A		; STORE
	DCX	D
	DCX	H
	LDAX	D		; GET HIGH ORDER BYTE
	MOV	M,A		; STORE
	DCX	D		; POINT TO NEW TOP
	RET

; STOX L,D		: STORE VARIABLE INDEXED IN LEVEL L, DISPLACEMENT D
;			: L IN A, D IN BC, INDEX ON TOP OF STACK
;			: STOX: LEVEL = 0, STOX1: LEVEL DIFFERENCE IN A
; 8080 STACK USAGE: 2+2+#'BASE'
STOX:	XRA	A		; LEVEL = 0
STOX1:	XCHG			; STACK POINTER TO HL
	MOV	E,M		; POP VALUE TO BE STORED IN DE
	DCX	H
	MOV	D,M
	DCX	H		; ADJUST STACK POINTER
	PUSH	D		; SAVE THAT VALUE
	MOV	E,M		; POP INDEX IN DE
	DCX	H
	MOV	D,M
	DCX	H		; POINT TO NEW STACK STOP
	XCHG			; STACK POINTER DE, INDEX IN HL
	DAD	H		; INDEX*2
	DAD	B		; ADD DISPLACEMENT
	MOV	B,H		; MOVE TO BC
	MOV	C,L
	LHLD	BB		; GET BASE ADDRESS IN HL
	ORA	A		; EXAMINE LEVEL DIFFERENCE
	CNZ	BASE		; GET APPROPRIATE BASE
	DAD	B		; ADD DISPLACEMENT
	POP	B		; RESTORE VALUE TO BE STORED
	MOV	M,C		; STORE
	DCX	H
	MOV	M,B		; STORE
	RET

; CALL 255,A		: CALL SUBROUTINE AT ABSOLUTE ADDRESS
; 8080 STACK USAGE: 2+#'POP1'
CALA:	CALL	POP1		; POP SUBROUTINE ADDRESS
	PCHL

; CALL L,A		: CALL PROCEDURE R FUNCTION WITH LEVEL L, AT ADDRESS A
;			: CAL: LEVEL DIFFERENCE = 0, CAL1: LEVEL DIFFERENCE IN A
; 8080 STACK USAGE: 2+#'BASE'
CAL:	XRA	A		; CLEAR LEVEL DIFFERENCE
CAL1:	LHLD	BB		; GET BASE ADDRESS
	MOV	B,H		; COPY IN BC
	MOV	C,L
	ORA	A		; EXAMINE LEVEL DIFFERENCE
	CNZ	BASE		; GET APPROPRIATE BASE
	PUSH	D		; SAVE STACK POINTER
	XCHG			; STACK POINTER TO HL
	INX	H
	MOV	M,D
	INX	H
	MOV	M,E
	SHLD	BB		; SAVE CURRENT STACK POINTER AS NEW BASE ADDRESS
	INX	H		; STORE OLD BASE ADDRESS AS DYNAMIC LINK
	MOV	M,B
	INX	H
	MOV	M,C
	POP	D		; RESTORE STACK POINTER
	POP	B		; GET RETURN ADDRESS
	PUSH	B		; AND RESAVE RETURN ADDRESS
	INX	B		; ADD 3
	INX	B
	INX	B
	INX	H		; PUSH RETURN ADDRESS
	MOV	M,B
	INX	H
	MOV	M,C
	RET

; INT 0,N		: INCREMENT STACK POINTER WITH N
; 8080 STACK USAGE: 2+#'PRINT' BYTES
INT:	DAD	D		; INCREMENT
	XCHG			; STACK POINTER TO DE
	LHLD	STACK2		; GET COMPLEMENT OF TOP OF STACK ROOM
	DAD	D
	RNC			; RETURN IF NO OVERFLOW
STKOV:	LXI	H,STVMSG	; PRINT STACK OVERFLOW MESSAGE
	CALL	PRINT
	JMP	EXIT		; ABORT

; 16 BIT ARITHMETIC ROUTINES

; 16 BIT ADD/SUBTRACT: HL +/- BC
; 8080 STACK USAGE: MAX(2+#'NEGB', #'PPUSH') BYTES
SUB1:	CALL	NEGB		; NEGATE BC
ADD16:	MOV	A,B		; GET SIGN BITS
SU2:	XRA	H
	DAD	B		; HL := HL + BC
	MOV	C,A		; SAVE SIGN BITS
	RAR			; GET CARRY BIT
	XRA	C		; XOR WITH SIGN BITS
	XRA	H		; MAKE SIGN BIT OF RESULT
	CM	OVFL		; PRINT OVERFLOW MESSAGE
	JMP	PPUSH		; PUSH RESULT, RETURN THERE

; 8 X 16 BITS MULTIPLY
; 8080 STACK USAGE: 0 BYTES
MUL8:	MVI	D,8		; 8 BITS TO SHIFT
MUL8$1:	DAD	H		; HL := HL*2 = HL SHL 1
	RLC			; GET A BIT
	JNC	MUL8$2		; SKIP IF ZERO
	DAD	B		; NOW HL := HL*2 + BC
MUL8$2:	DCR	D		; DECREMENT BIT COUNT
	JNZ	MUL8$1		; LOOP FOR NEXT BIT IF ANY
	RET

; 16 BIT DIVIDE
; 8080 STACK USAGE: 6 BYTES
DIV16:	MOV	A,B		; CHECK FOR /0 ERROR
	ORA	C
	JZ	DVCK		; JUMP IF SO
	XRA	A		; CLEAR A
	ADD	B		; SAVE SIGN OF DIVISOR
	PUSH	PSW
	CP	NEGB		; IF BC>=0 THEN THEN BC := -BC
	XRA	A		; CLEAR A
	ADD	H		; SAVE SIGN OF DIVIDENT
	PUSH	PSW
	CM	NEGH		; IF HL<0 THEN HL := -HL
	XCHG			; DIVIDENT IN DE
	LXI	H,0		; INIT RESULT
	MVI	A,16		; COUNTER FOR 16 BITS
DIV16$1:DAD	H		; SHIFT HL
	XCHG			; SHIFT DE
	DAD	H
	XCHG
	JNC	DIV16$2
	INX	H
DIV16$2:PUSH	H		; SAVE HL
	DAD	B
	JNC	DIV16$3
	INR	E		; PUT 1 IN LOW ORDER BIT OF DE
	INX	SP		; THROW AWAY OLD HL
	INX	SP
	DCR	A		; DECREMENT BIT COUNTER
	JNZ	DIV16$1		; LOOP FOR NEXT BIT
	JMP	DIV16$4

DIV16$3:POP	H		; GET OLD HL
	DCR	A
	JNZ	DIV16$1
DIV16$4:XCHG			; SWITCH QUOTIENT AND REMAINDER
	POP	B		; SIGN OF DIVIDENT
	POP	PSW		; SIGN OF DIVISOR
	XRA	B
	CM	NEGH		; NEGATE RESULT
	MOV	A,D		; RAMAINDER 0?
	ORA	E
	RZ
	XRA	A
	ADD	B		; DIVIDENT >= 0?
	RP
	XRA	A
	SUB	E		; NEGATE REAMINDER
	MOV	E,A
	SBB	D
	SUB	E
	MOV	D,A
	RET

; COMPARE ROUTINES

; TEST FOR EQUAL/NOT EQUAL:	FLAG IN A
; 8080 STACK USAGE: 2+MAX(2+#'PPOP', #'NOT$EQ') BYTES
EQUAL:	PUSH	PSW		; SAVE FLAG
	CALL	PPOP		; POP TOP TWO ELEMENTS
	XRA	A		; CLEAR HIGH ORDER BYTE OF RESULTS
	INX	D
	STAX	D
	INX	D
	MOV	A,L		; TEST LOW ORDER BYTE
	CMP	C
	JNZ	NOT$EQ
	MOV	A,H		; TEST HIGH ORDER BYTES
	CMP	B
	JNZ	NOT$EQ
	POP	PSW
	STAX	D		; STORE RESULTS
	RET

; 8080 STACK USAGE: 0 BYTES
NOT$EQ:	POP	PSW
	XRI	1		; FLIP BIT 0
	STAX	D
	RET

; TEST FOR LESS OR EQUAL/MORE
; 8080 STACK USAGE: 4+#'PPOP' BYTES
LESS:	PUSH	B		; SAVE FLAGS
	CALL	PPOP		; POP TOP TWO ELEMENTS
	INX	D		; POINT TO HIGH ORDER BYTE OF RESULT
	XRA	A		; CLEAR HIGH ORDER BYTE
	STAX	D
	INX	D
	MOV	A,H		; TEST HIGH ORDER BYTES
	CMP	B
	JZ	LESS1
	RAR
	XRA	H
	XRA	B
	JM	LESS3
	POP	PSW
	XRI	1		; FLIP BIT 0
	STAX	D
	RET

LESS1:	MOV	A,L		; COMPARE LOW ORDER BYTES
	CMP	C
	JC	LESS3
	POP	B		; POP FLAGS
	MOV	A,B
	JNZ	LESS2
	XRA	C
LESS2:	XRI	1
	STAX	D
	RET

LESS3:	POP	PSW
	STAX	D
	RET

; NEGATE HL
; 8080 STACK USAGE: 2+#'OVFL' BYTES
NEGH:	XRA	A
	SUB	L
	MOV	L,A
	SBB	H
	SUB	L
	MOV	H,A
	SUI	80H
	ORA	L
	CZ	OVFL
	RET

; NEGATE BC
; 8080 STACK USAGE: 2+#'OVFL' BYTES
NEGB:	XRA	A
	SUB	C
	MOV	C,A
	SBB	B
	SUB	C
	MOV	B,A
	SUI	80H
	ORA	C
	CZ	OVFL
	RET

; REPORT OVERFLOW
; 8080 STACK USAGE: 4+#'PRINT'
OVFL:	PUSH	H
	LXI	H, OVFMSG
	CALL	PRINT
	POP	H
	RET

; REPORT /0
; 8080 STACK USAGE: 2+#'PRINT'
DVCK:	LXI	H,DV0MSG
	CALL	PRINT
	LXI	H,0
	MOV	D,H
	MOV	E,L
	RET

; STACK MANIPULATION ROUTINES

; PPOP:	: POP TOP TWO ELEMENTS
;		: [SP] TO BC
;		: [SP-1] TO HL
; 8080 STACK USAGE: 0 BYTES
PPOP:	XCHG	; STACK POINTER TO HL
	MOV	C,M		; GET LSB
	DCX	H
	MOV	B,M		; GET MSB
	DCX	H
	MOV	E,M		; GET [SP-1]
	DCX	H
	MOV	D,M
	XCHG			; STACK POINTER BACK TO DE
	DCX	D		; ADJUST STACK POINTER
	RET

; POP1		: POP TOP ELEMENT TO HL
; 8080 STACK USAGE: 0 BYTES
POP1:	XCHG
	MOV	E,M
	DCX	H
	MOV	D,M
	XCHG			; STACK POINTER BACK TO DE
	DCX	D		; ADJUST STACK POINTER
	RET

; PPUSH		: PUSH HL ON STACK
; 8080 STACK USAGE: 0 BYTES
PPUSH:	XCHG			; GET STACK POINTER INHL
	INX	H
	MOV	M,D
	INX	H
	MOV	M,E
	XCHG			; STACK POINTER BACK TO DE
	RET

; BASE		: GET BASE ADDRESS AT LEVEL L
;		: CURRENT BASE ADDRES IN HL
;		: REQUIRED LEVEL IN A
; 8080 STACK USAGE: 2 BYTES
BASE:	PUSH	D		; SAVE STACK POINTER
BASE$1:	MOV	E,M		; GET PREVIOUS BASE
	DCX	H
	MOV	D,M
	XCHG			; SWAP PREVIOUS BASE IN HL
	DCR	A		; COUNT DOWN
	JNZ	BASE$1		; JUMP FOR NEXT
	POP	D		; RESTORE STACK POINTER
	RET

; IO ROUTINES

; INP		: INPUT A CHARACTER, SYNCHRONOUS
; 8080 STACK USAGE: 8 BYTES
INP:	PUSH	B
	PUSH	D
	PUSH	H
	MVI	C,B$CONIN
	CALL BDOS
	POP	H
	POP	D
	POP	B
	RET

; OUTP		: OUTPUT A CHARACTER, SYNCHRONOUS
; 8080 STACK USAGE: 10 BYTES
OUTP:	PUSH	PSW
	PUSH	B
	PUSH	D
	PUSH	H
	MVI	C,B$CONOUT
	MOV	E,A
	CALL BDOS
	POP	H
	POP	D
	POP	B
	POP	PSW
	RET

; INPUT TWO HEX DIGITS
; 8080 STACK USAGE: 2+MAX(#'IHX', #'INP',#'PRINT')
INHEX:	CALL	IHX
	RC
	RLC			; MOVE TO MS NIBBLE
	RLC
	RLC
	RLC
	MOV	C,A		; SAVE RESULT

; INPUT ONE HEX DIGIT
; 8080 STACK USAGE: 2+MAX(#'INP',#'PRINT')
IHX:	CALL	INP		; GET A CHARACTER
	SUI	'0'		; MAKE VALUE FROM CHARACTER
	JC	IHX$1		; REPORT INPUT ERROR IF LESS THAN '0'
	CPI	10		; IS VALUE LARGER THAN 10?
	CMC			; MAKE SURE THE CY HAS THE RIGHT VALUE
	RNC			; OK (AND NO CY) IF LESS THAN 10
	SUI	'A'-'9'-1	; SEE IF IN 'A'-'F'
	JC	IHX$1		; IF LESS THAN 'A', REPORT ERROR
	CPI	16		; IS VALUE LARGER THAN 16?
	CMC			; MAKE SURE THE CY HAS THE RIGHT VALUE
	RNC			; OK (AND NO CY) IF LESS THAN 10
IHX$1:	LXI	H,MER1		; LOAD ERROR MESSAGE
	CALL	PRINT		; PRINT ERROR MESSAGE
	STC			; SET CY AS ERROR FLAG
	RET

; PRINT TWO HEX DIGITS, VALUE IN A
; 8080 STACK USAGE: MAX(2+#'HEX$1', #'OUTP') BYTES
HEX:	MOV	C,A		; SAVE VALUE
	ANI	11110000B	; MASK OFF MS NIBBLE
	RRC			; MOVE TO LS NIBBLE
	RRC
	RRC
	RRC	
	CALL	HEX$1
	MOV	A,C		; GET VALUE BACK
	ANI	00001111B	; MASK OFF LS NIBBLE
HEX$1:	CPI	10		; MORE THAN 10?
	JM	HEX$2		; JUMP IF LESS THAN 10
	ADI	'A'-'9'-1	; FIRST STAGE IN CONVERTING VALUE TO CHARACTER
HEX$2:	ADI	'0'		; CONVERT TO CHARACTER
	JMP	OUTP		; PRINT VALUE, RETURN THERE

; PRINT AN ERROR MESSAGE
; 8080 STACK USAGE: 2+#'OUTPUT'
PRINT:	MOV	A,M
	ORA	A
	RZ
	INX	H
	CALL	OUTP
	JMP	PRINT

EXIT:	MVI	C,B$SYSRESET
	JMP	BDOS

; MESSAGES
MER1:	DB	' INPUT ERROR', CR, LF, 0
MER2:	DB	' SIZE ERROR', CR, LF, 0
STVMSG:	DB	' STACK'
OVFMSG:	DB	' OVERFLOW', CR, LF, 0
DV0MSG:	DB	' DIVISION BY ZERO', CR, LF, 0

; STORAGE

SIGN:	DB	' '		; SIGN FLAG BYTE

PRIVATE$STACK:
	DB	0DEH, 0ADH, 0BEH, 0EFH
	DB	0DEH, 0ADH, 0BEH, 0EFH
	DB	0DEH, 0ADH, 0BEH, 0EFH
	DB	0DEH, 0ADH, 0BEH, 0EFH
	DB	0DEH, 0ADH, 0BEH, 0EFH
	DB	0DEH, 0ADH, 0BEH, 0EFH
	DB	0DEH, 0ADH, 0BEH, 0EFH
	DB	0DEH, 0ADH, 0BEH, 0EFH

; END OF TINY PASCAL RUN TIME ROUTINES, BEGIN OF TRANSLATED P-CODE
PROGB:	END	0100H
