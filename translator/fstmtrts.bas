10 DEFINT A-Z:FALSE=0:TRUE=NOT FALSE
20 CLS$=CHR$(27)+"[2J"+CHR$(27)+"[H":SGNON$=CLS$+"TINY PASCAL RUN-TIME SYSTEM GENERATOR"
30 RTSFNAME$="TPRTS$$$.C$M":TRTFNAME$="TPRTSADR.TBL":PRUN.FN$="PRUN.HEX"
100 DEF FNMEMW(I!)=I!+(I!>32767)*65536!:REM TURN REAL NUMBER POSSIBLY LARGER THAN 32676 INTO AN INT BETWEEN -32768 AND 32767
101 DEF FNHEXN$(A,N)=STRING$(N-LEN(HEX$(A)),"0")+HEX$(A):DEF FNHEXNF$(A!,N)=FNHEXN$(FNMEMW(A!),4):REM MAKE AN N-DIGIT HEX-REPRESENTATION OF A
102 DEF FNABSW!(I.)=I.-(I.<0)*65536!:REM TURN INTEGER I BETWEEN -32768 AND 32767 INTO A REAL BETWEEN 0 AND 65535
103 DEF FNHIGH.BYTE(I)=INT(FNABSW!(I)/256):DEF FNLOW.BYTE(I)=FNABSW!(I)-FNHIGH.BYTE(I)*256:REM GET THE MSB, OR THE LSB OF A WORD
104 DEF FNEO.PCFILE(CO1, CO2)= CO1=&HFFFF AND CO2=&HFFFF:REM END OF PCODE FILE
105 DEF FNUC$(A$)=CHR$((ASC(A$)>=ASC("a")AND ASC(A$)<=ASC("z"))*(ASC("a")-ASC("A"))+ASC(A$))
106 DEF FNDIVF!(A!,B!)=INT(A!/B!):DEF FNMODF!(A!,B!)=A!-INT(A!/B!)*B!

110 ON ERROR GOTO 800:OPEN"I",#1,PRUN.FN$:GOSUB 10000
120 OPEN"I",#2,RTSFNAME$:INPUT"RTS FILE EXISTS! OVERWRITE";ANS$:IF FNUC$(LEFT$(ANS$,1))<>"Y"THEN STOP
130 CLOSE#2:OPEN"R",#2,RTSFNAME$,128:FIELD#2,128 AS SCT$:SNM=0:REM USE 128 BYTE SECTORS, SNM IS CACHED SECTOR NUMER (STARTS AT 1!)
135 AC.PI!=FNABSW!(&H0100):?"Opened "RTSFNAME$
140 OPEN"I",#3,TRTFNAME$:INPUT"RTS ADDRESS TABLE FILE EXISTS! OVERWRITE";ANS$:IF FNUC$(LEFT$(ANS$,1))<>"Y"THEN STOP
150 CLOSE#3:OPEN"R",#3,TRTFNAME$,2:FIELD#3,2 AS ADDR.WORD$:A.W.INDEX=1:?"Opened "TRTFNAME$
160 ON ERROR GOTO 0

200 GOSUB 8000
210 GOSUB 7000
220 CLOSE#1,#2,#3
230 ?"Done"
240 STOP

800 IF ERR=53 AND ERL=120 THEN RESUME 130
810 IF ERR=53 AND ERL=140 THEN RESUME 150
820 ON ERROR GOTO 0

7000 PRINT"Copying RTS"
7010 GOSUB 10150:WHILE NOT PREOF:GOSUB 7200:GOSUB 10150:WEND:?
7020 IF PROR!<>AC.PI!THEN PRINT"Sync error: Assembly code does not start at ";FNHEXN$(FNMEMW(PROR!),4);" but at ";FNHEXN$(FNMEMW(AC.PI!),4):STOP
7030 PUT#2,SNM
7040 PRINT" Done copying RTS"
7050 RETURN
7200 AC.PN=FNDIVF!(AC.PI!-&H0100,128):AC.OFS=FNMODF!(AC.PI!-&H0100,128)
7210 IF AC.PN<>SNM-1 THEN GOSUB 7300
7220 MID$(SCT$,AC.OFS+1)=CHR$(PRVALUEB):AC.PI!=AC.PI!+1:RETURN
7300 IF SNM<>0 THEN PUT#2,SNM:?CHR$(13)" Writing page "FNHEXN$(AC.PN,2);
7310 SNM=AC.PN+1:GET#2,SNM
7320 RETURN

8000 PRINT"Reading RTS table"
8005 PRID$="":FOR I=1 TO 4:GOSUB 10150:PRID$=PRID$+CHR$(PRVALUEB):NEXT:IF PRID$<>"PR01"THEN PRINT"ERROR: FILE ID '";PRID$;"' => 'PRO1'":STOP 
8006 FOR I=1 TO LEN(PRID$)/2-((LEN(PRID$) MOD 2) <> 0):LSET ADDR.WORD$=MID$(PRID$,(I-1)*2+1,2):GOSUB 8510:NEXT
8010 GOSUB 10170:TABLELEN=PRVALUEW:PRINT"RTS tablelength:";TABLELEN:ADDR.WORD=TABLELEN:GOSUB 8500
8020 FOR I=1 TO TABLELEN:GOSUB 10170:ADDR.WORD=PRVALUEW:GOSUB 8500:NEXT
8030 GOSUB 10170:PROR!=FNABSW!(PRVALUEW):ADDR.WORD=PRVALUEW:GOSUB 8500
8035 PRINT"PROGRAM STARTS AT ";FNHEXN$(FNMEMW(PROR!),4)
8050 PRINT" Done reading RTS table"
8060 RETURN

8500 LSET ADDR.WORD$=MKI$(ADDR.WORD)
8510 PUT#3,A.W.INDEX:A.W.INDEX=A.W.INDEX+1:RETURN

10000 PRVALUESINDEX=0:PRLINELEN=0:PRMAXLEN=16:DIM PRVALUES[PRMAXLEN-1]:RETURN:REM INITIALISE READING THE PRUN-FILE
10001 REM PRVALUESINDEX KEEPS TRACK OF THE NUMBER OF VALUES READ FROM THE PRVALUES ARRAY
10002 REM PRLINELEN CONTAINS THE NUMBER OF VLUES ON THIS LINE
10003 REM PRMAXLEN IS THE MAXIMUN NUMBER OF VALUES IN A HEX RECORD. THIS IS NORMALLY 16, BUT IT MAY BE MORE
10010 LINE INPUT#1,PRLINE$:PRLINEINDEX=1
10020 IF MID$(PRLINE$,PRLINEINDEX,1)<>":"THEN PRINT"ERROR: LINE DOES NOT START WITH A':'";PRLINE$:STOP:REM A LINE IN A HEX-FILE STARTS WITH A ":"
10030 PRLINEINDEX=PRLINEINDEX+1
10040 PRLINELEN=VAL("&H"+MID$(PRLINE$,PRLINEINDEX,2)):PRLINEINDEX=PRLINEINDEX+2:REM THE FIRST TWO BYTES OF A LINE CONTAIN THE NUMBER OF HEX VALUES ON THIS LINE
10050 IF PRLINELEN>PRMAXLEN THEN ERASE PRVALUES:PRMAXLEN=PRLINELEN:DIM PRVALUES[PRMAXLEN-1]:REM IF WE RESERVED INSUFFICIENT ROOM FOR VALUES, ADJUST. NORMALLY, 16 VALUES SHOULD SUFFICE, MAX IS 256
10060 PRLINEADR!=VAL("&H"+MID$(PRLINE$,PRLINEINDEX,4)):PRLINEINDEX=PRLINEINDEX+4:REM THE NEXT TWO BYTES CONTAIN THE LOAD ADDRESS FOR THE VALUES
10070 PRLINETYPE=VAL("&H"+MID$(PRLINE$,PRLINEINDEX,2)):PRLINEINDEX=PRLINEINDEX+2:REM THE NEXT TWO BYTES CONTAIN THE RECORD TYPE FOR THIS LINE
10080 FOR PR.I=0 TO PRLINELEN-1:PRVALUES[PR.I]=VAL("&H"+MID$(PRLINE$,PRLINEINDEX,2)):PRLINEINDEX=PRLINEINDEX+2:NEXT:REM READ PRLINELEN VALUES FROM FILE AND STORE IN PRVALUES
10090 PRCHECKSUM=PRLINELEN+FNMODF!(PRLINEADR!,256)+FNDIVF!(PRLINEADR!,256)+PRLINETYPE:REM THE CHECKSUM CONSISTS OF ALL BYTES ON A LINE SUMMED MODULO 256
10100 FOR PR.I=0 TO PRLINELEN-1:PRCHECKSUM=PRCHECKSUM+PRVALUES[PR.I]:NEXT
10110 PRCHECKSUM=PRCHECKSUM+VAL("&H"+MID$(PRLINE$,PRLINEINDEX,2)):REM ADD ALL VALUES
10120 IF PRCHECKSUM MOD 256<>0 THEN PRINT "CHECKSUM ERROR":REM THE CHECKSUM MOD 256 SHOULD BE 0
10130 PRVALUESINDEX=0:REM AFTER READING A FRESH LINE FROM THE PRUN.HEX FILE WE START RETURNING VALUES FROM 0
10140 PREOF=(PRLINELEN=0):IF PREOF THEN RETURN:IF AT END OF FILE, THEN RETURN AFTER SETTING THE PROEF FLAG
10149 REM THE NEXT LINE IS THE ENTRY POINT FOR READING THE NEXT BYTE FROM THE PRUN.HEX FILE
10150 IF PRVALUESINDEX=PRLINELEN THEN GOTO 10010:REM IF WE EXHAUSTED ALL VALUES ON A LINE, GET THE NEXT LINE
10160 PRVALUEB=PRVALUES[PRVALUESINDEX]:PRVALUEADDR!=PRLINEADR!+PRVALUESINDEX:PRVALUESINDEX=PRVALUESINDEX+1:RETURN
10169 REM READ NEXT WORD FROM THE FILE. CAVEAT: THE WORD MAY BE SPLIT OVER TWO LINES!
10170 GOSUB 10150:PRVALUEW=PRVALUEB:GOSUB 10150:PRVALUEW=FNMEMW(CSNG(PRVALUEW)+CSNG(PRVALUEB)*256):PRVALUEADDR!=PRVALUEADDR!-1:RETURN

